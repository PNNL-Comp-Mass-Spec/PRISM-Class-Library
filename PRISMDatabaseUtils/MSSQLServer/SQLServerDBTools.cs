using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text;
using PRISM;

namespace PRISMDatabaseUtils.MSSQLServer
{
    /// <summary>
    /// Tools to retrieve data from a database or run stored procedures
    /// </summary>
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    internal class SQLServerDBTools : DBToolsBase, IDBTools
    {
        // Ignore Spelling: cmd, Cn, msg, Sql, varchar

        #region "Member Variables"

        private string mConnStr;

        /// <summary>
        /// Timeout length, in seconds, when waiting for a query or stored procedure to finish running
        /// </summary>
        private int mTimeoutSeconds;

        #endregion

        #region "Properties"

        /// <summary>
        /// Database connection string
        /// </summary>
        public string ConnectStr
        {
            get => mConnStr;
            set
            {
                if (string.IsNullOrWhiteSpace(value))
                {
                    throw new Exception("Connection string cannot be empty");
                }
                mConnStr = value;
                ParseConnectionString(value);
            }
        }

        /// <summary>
        /// Database server type
        /// </summary>
        public DbServerTypes DbServerType => DbServerTypes.MSSQLServer;

        /// <summary>
        /// Set to True to raise debug events
        /// </summary>
        public bool DebugMessagesEnabled { get; set; }

        /// <summary>
        /// Timeout length, in seconds, when waiting for a query to finish executing
        /// </summary>
        public int TimeoutSeconds
        {
            get => mTimeoutSeconds;
            set
            {
                if (value <= 0)
                    value = DbUtilsConstants.DEFAULT_SP_TIMEOUT_SEC;

                if (value < 10)
                    value = 10;

                mTimeoutSeconds = value;
            }
        }

        /// <summary>
        /// The name of the server to which the connection string connects
        /// </summary>
        public string ServerName { get; private set; }

        /// <summary>
        /// The name of the database to which the connection string connects
        /// </summary>
        public string DatabaseName { get; private set; }

        #endregion

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="connectionString">Database connection string</param>
        /// <param name="timeoutSeconds">Query timeout, in seconds</param>
        /// <param name="debugMode">When true, show queries and procedure calls using OnDebugEvent</param>
        public SQLServerDBTools(
            string connectionString,
            int timeoutSeconds = DbUtilsConstants.DEFAULT_SP_TIMEOUT_SEC,
            bool debugMode = false)
        {
            ConnectStr = connectionString;
            mTimeoutSeconds = timeoutSeconds;
            DebugMessagesEnabled = debugMode;
        }

        private void ParseConnectionString(string connectionString)
        {
            var builder = new SqlConnectionStringBuilder(connectionString);
            ServerName = builder.DataSource ?? string.Empty;
            DatabaseName = builder.InitialCatalog ?? string.Empty;
        }

        /// <summary>
        /// This method is an event handler for InfoMessage event
        /// </summary>
        /// <remarks>
        /// The errors and warnings sent from the SQL server are caught here
        /// </remarks>
        private void OnInfoMessage(object sender, SqlInfoMessageEventArgs args)
        {
            var message = new StringBuilder();

            foreach (SqlError err in args.Errors)
            {
                // Class is the severity level of the message returned from SQL Server
                var severity = err.Class;

                // ReSharper disable CommentTypo

                // Levels 0 through 10 are informational messages; this includes print statements in a stored procedure
                // Levels 11 through 16 are generated by the user, e.g. RAISERROR('Error message', 11, 20)
                // Levels 17 through 25 indicate software or hardware errors
                //   The SqlConnection remains open when the severity level is 19 or less
                //   When the severity level is 20 or greater, the server usually closes the SqlConnection

                // ReSharper restore CommentTypo

                if (severity <= 10)
                {
                    if (string.IsNullOrWhiteSpace(err.Procedure))
                        OnDebugEvent(err.Message);
                    else
                        OnDebugEvent(string.Format("{0}: {1}", err.Procedure, err.Message));

                    continue;
                }

                message.Clear();
                message.Append("Message: " + err.Message);
                message.Append(", Source: " + err.Source);
                message.Append(", Class: " + err.Class);
                message.Append(", State: " + err.State);
                message.Append(", Number: " + err.Number);
                message.Append(", LineNumber: " + err.LineNumber);
                message.Append(", Procedure:" + err.Procedure);
                message.Append(", Server: " + err.Server);

                if (severity <= 16)
                {
                    OnWarningEvent(message.ToString());
                }
                else
                {
                    OnErrorEvent(message.ToString());
                }
            }
        }

        /// <summary>
        /// Get a disconnected dataset as specified by the SQL statement
        /// </summary>
        /// <param name="sqlQuery">A SQL string</param>
        /// <param name="DS">A dataset</param>
        /// <param name="rowCount">A row counter</param>
        /// <returns>Returns a disconnected dataset as specified by the SQL statement</returns>
        [Obsolete("Use GetQueryResults since support for dataset objects is unavailable in .NET Standard 1.0; Use GetQueryResultsDataset.", true)]
        public bool GetDiscDataSet(string sqlQuery, ref DataSet DS, ref int rowCount)
        {
            var retryCount = 3;
            var retryDelaySeconds = 5;

            while (retryCount > 0)
            {
                try
                {
                    using var dbConnection = new SqlConnection(ConnectStr);

                    dbConnection.InfoMessage += OnInfoMessage;

                    // Get the dataset
                    var adapter = new SqlDataAdapter(sqlQuery, dbConnection);
                    DS = new DataSet();
                    rowCount = adapter.Fill(DS);
                    return true;
                }
                catch (Exception ex)
                {
                    retryCount--;
                    var errorMessage =
                        string.Format("Exception querying database ({0}; ConnectionString: {1}, RetryCount = {2}, Query {3}",
                                      ex.Message, ConnectStr, retryCount, sqlQuery);

                    OnErrorEvent(errorMessage);

                    // Delay for 5 seconds before trying again
                    ProgRunner.SleepMilliseconds(retryDelaySeconds * 1000);
                }
            }

            return false;
        }

        /// <summary>
        /// Run a query against a SQL database, return the scalar result
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="sqlQuery">Query to run</param>
        /// <param name="queryResult">Result (single value) returned by the query</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="timeoutSeconds">Number of seconds to set as the command timeout; if &lt;=0, <see cref="TimeoutSeconds"/> is used</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryScalar(
            string sqlQuery,
            out object queryResult,
            int retryCount = 3,
            int retryDelaySeconds = 5,
            int timeoutSeconds = -1,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            if (timeoutSeconds <= 0)
            {
                timeoutSeconds = TimeoutSeconds;
            }

            var cmd = new SqlCommand(sqlQuery) { CommandType = CommandType.Text, CommandTimeout = timeoutSeconds };
            return GetQueryScalar(cmd, out queryResult, retryCount, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL database, return the scalar result
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="cmd">Query to run</param>
        /// <param name="queryResult">Result (single value) returned by the query</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryScalar(
            DbCommand cmd,
            out object queryResult,
            int retryCount = 3,
            int retryDelaySeconds = 5,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            if (string.IsNullOrWhiteSpace(callingFunction))
            {
                callingFunction = "UnknownCaller";
            }

            if (cmd is not SqlCommand sqlCmd)
            {
                if (cmd == null)
                {
                    throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of 'null'.", nameof(cmd));
                }

                throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of type {cmd.GetType().FullName}.", nameof(cmd));
            }

            if (retryCount < 1)
                retryCount = 1;

            if (retryDelaySeconds < 1)
                retryDelaySeconds = 1;

            // Make sure we dispose of the command object; however, it must be done outside of the while loop (since we use the same command for retries)
            // Could use clones for each try, but that would cause problems with "Output" parameters
            using (sqlCmd)
            {
                while (true)
                {
                    try
                    {
                        using var dbConnection = new SqlConnection(ConnectStr);

                        dbConnection.InfoMessage += OnInfoMessage;
                        dbConnection.Open();

                        sqlCmd.Connection = dbConnection;

                        if (DebugMessagesEnabled)
                        {
                            OnDebugEvent("GetQueryScalar: " + sqlCmd.CommandText);
                        }

                        queryResult = sqlCmd.ExecuteScalar();

                        return true;
                    }
                    catch (Exception ex)
                    {
                        retryCount--;
                        if (string.IsNullOrWhiteSpace(callingFunction))
                        {
                            callingFunction = "Unknown";
                        }
                        var errorMessage = string.Format(
                            "Exception querying database (called from {0}): {1}; " +
                            "ConnectionString: {2}, RetryCount = {3}, Query {4}",
                            callingFunction, ex.Message, ConnectStr, retryCount, sqlCmd);

                        OnErrorEvent(errorMessage);

                        if (IsFatalException(ex))
                        {
                            // No point in retrying the query; it will fail again
                            queryResult = null;
                            return false;
                        }

                        if (retryCount <= 0)
                            break;

                        // Delay for 5 seconds before trying again
                        ProgRunner.SleepMilliseconds(retryDelaySeconds * 1000);
                    }
                }
            }

            queryResult = null;
            return false;
        }

        /// <summary>
        /// Run a query against a SQL Server database, return the results as a list of strings
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// Null values are converted to empty strings
        /// Numbers are converted to their string equivalent
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="sqlQuery">Query to run</param>
        /// <param name="results">Results (list of list of strings)</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="maxRowsToReturn">Maximum rows to return; 0 to return all rows</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="timeoutSeconds">Number of seconds to set as the command timeout; if &lt;=0, <see cref="TimeoutSeconds"/> is used</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryResults(
            string sqlQuery,
            out List<List<string>> results,
            int retryCount = 3,
            int maxRowsToReturn = 0,
            int retryDelaySeconds = 5,
            int timeoutSeconds = -1,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            if (timeoutSeconds <= 0)
            {
                timeoutSeconds = TimeoutSeconds;
            }

            var cmd = new SqlCommand(sqlQuery) { CommandType = CommandType.Text, CommandTimeout = timeoutSeconds };
            return GetQueryResults(cmd, out results, retryCount, maxRowsToReturn, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL Server database, return the results as a list of strings
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// Null values are converted to empty strings
        /// Numbers are converted to their string equivalent
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="cmd">Query to run</param>
        /// <param name="results">Results (list of list of strings)</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="maxRowsToReturn">Maximum rows to return; 0 to return all rows</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryResults(
            DbCommand cmd,
            out List<List<string>> results,
            int retryCount = 3,
            int maxRowsToReturn = 0,
            int retryDelaySeconds = 5,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            // Declare a local variable to append the results to
            // This is required because we cannot use an out parameter in a lambda expression (the Action => block below)
            var dbResults = new List<List<string>>();
            results = dbResults;

            var readMethod = new Action<SqlCommand>(x =>
            {
                using var reader = x.ExecuteReader();

                if (!reader.HasRows)
                {
                    return;
                }

                while (reader.Read())
                {
                    var currentRow = new List<string>();

                    for (var columnIndex = 0; columnIndex < reader.FieldCount; columnIndex++)
                    {
                        var value = reader.GetValue(columnIndex);

                        if (DBNull.Value.Equals(value))
                        {
                            currentRow.Add(string.Empty);
                        }
                        else
                        {
                            currentRow.Add(value.ToString());
                        }
                    }

                    dbResults.Add(currentRow);

                    if (maxRowsToReturn > 0 && dbResults.Count >= maxRowsToReturn)
                    {
                        break;
                    }
                }
            });

            return GetQueryResults(cmd, readMethod, retryCount, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL database, return the results as a DataTable object
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="sqlQuery">Query to run</param>
        /// <param name="queryResults">Results (as a DataTable)</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="timeoutSeconds">Number of seconds to set as the command timeout; if &lt;=0, <see cref="TimeoutSeconds"/> is used</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryResultsDataTable(
            string sqlQuery,
            out DataTable queryResults,
            int retryCount = 3,
            int retryDelaySeconds = 5,
            int timeoutSeconds = -1,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            if (timeoutSeconds <= 0)
            {
                timeoutSeconds = TimeoutSeconds;
            }

            var cmd = new SqlCommand(sqlQuery) { CommandType = CommandType.Text, CommandTimeout = timeoutSeconds };
            return GetQueryResultsDataTable(cmd, out queryResults, retryCount, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL database, return the results as a DataTable object
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="cmd">Query to run</param>
        /// <param name="queryResults">Results (as a DataTable)</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryResultsDataTable(
            DbCommand cmd,
            out DataTable queryResults,
            int retryCount = 3,
            int retryDelaySeconds = 5,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            var results = new DataTable();
            queryResults = results;
            var readMethod = new Action<SqlCommand>(x =>
            {
                using var da = new SqlDataAdapter(x);
                da.Fill(results);
            });

            return GetQueryResults(cmd, readMethod, retryCount, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL database, return the results as a DataSet object
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="sqlQuery">Query to run</param>
        /// <param name="queryResults">Results (as a DataSet)</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="timeoutSeconds">Number of seconds to set as the command timeout; if &lt;=0, <see cref="TimeoutSeconds"/> is used</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryResultsDataSet(
            string sqlQuery,
            out DataSet queryResults,
            int retryCount = 3,
            int retryDelaySeconds = 5,
            int timeoutSeconds = -1,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            if (timeoutSeconds <= 0)
            {
                timeoutSeconds = TimeoutSeconds;
            }

            var cmd = new SqlCommand(sqlQuery) { CommandType = CommandType.Text, CommandTimeout = timeoutSeconds };
            return GetQueryResultsDataSet(cmd, out queryResults, retryCount, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL database, return the results as a DataSet object
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="cmd">Query to run</param>
        /// <param name="queryResults">Results (as a DataSet)</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        public bool GetQueryResultsDataSet(
            DbCommand cmd,
            out DataSet queryResults,
            int retryCount = 3,
            int retryDelaySeconds = 5,
            [CallerMemberName] string callingFunction = "UnknownMethod")
        {
            var results = new DataSet();
            queryResults = results;
            var readMethod = new Action<SqlCommand>(x =>
            {
                using var da = new SqlDataAdapter(x);
                da.Fill(results);
            });

            return GetQueryResults(cmd, readMethod, retryCount, retryDelaySeconds, callingFunction);
        }

        /// <summary>
        /// Run a query against a SQL database, return the results via <paramref name="readMethod"/>
        /// </summary>
        /// <remarks>
        /// Uses the connection string passed to the constructor of this class
        /// By default, retries the query up to 3 times
        /// </remarks>
        /// <param name="cmd">Query to run</param>
        /// <param name="readMethod">method to read and return data from the command; command will be ready to run, executing and processing of returned data is left to the this Action</param>
        /// <param name="retryCount">Number of times to retry (in case of a problem)</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <param name="callingFunction">Name of the calling method (for logging purposes)</param>
        /// <returns>True if success, false if an error</returns>
        private bool GetQueryResults(
            DbCommand cmd,
            Action<SqlCommand> readMethod,
            int retryCount,
            int retryDelaySeconds,
            string callingFunction)
        {
            if (string.IsNullOrWhiteSpace(callingFunction))
            {
                callingFunction = "UnknownCaller";
            }

            if (cmd is not SqlCommand sqlCmd)
            {
                if (cmd == null)
                {
                    throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of 'null'.", nameof(cmd));
                }

                throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of type {cmd.GetType().FullName}.", nameof(cmd));
            }

            if (retryCount < 1)
                retryCount = 1;

            if (retryDelaySeconds < 1)
                retryDelaySeconds = 1;

            // Make sure we dispose of the command object; however, it must be done outside of the while loop (since we use the same command for retries)
            // Could use clones for each try, but that would cause problems with "Output" parameters
            using (sqlCmd)
            {
                while (true)
                {
                    try
                    {
                        using var dbConnection = new SqlConnection(ConnectStr);

                        dbConnection.InfoMessage += OnInfoMessage;
                        dbConnection.Open();

                        sqlCmd.Connection = dbConnection;

                        if (DebugMessagesEnabled)
                        {
                            OnDebugEvent("GetQueryResults: " + sqlCmd.CommandText);
                        }

                        readMethod(sqlCmd);

                        return true;
                    }
                    catch (Exception ex)
                    {
                        retryCount--;
                        if (string.IsNullOrWhiteSpace(callingFunction))
                        {
                            callingFunction = "Unknown";
                        }
                        var errorMessage = string.Format(
                            "Exception querying database (called from {0}): {1}; " +
                            "ConnectionString: {2}, RetryCount = {3}, Query {4}",
                            callingFunction, ex.Message, ConnectStr, retryCount, sqlCmd);

                        OnErrorEvent(errorMessage);

                        if (IsFatalException(ex))
                        {
                            // No point in retrying the query; it will fail again
                            return false;
                        }

                        if (retryCount <= 0)
                            break;

                        // Delay for 5 seconds before trying again
                        ProgRunner.SleepMilliseconds(retryDelaySeconds * 1000);
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Update a database table as specified in the SQL statement
        /// </summary>
        /// <param name="SQL">A SQL string</param>
        /// <param name="affectedRows">Affected Rows to be updated</param>
        /// <returns>Returns Boolean showing if the database was updated</returns>
        [Obsolete("Functionality of this method has been disabled for safety; an exception will be raised if it is called")]
        public bool UpdateDatabase(string SQL, out int affectedRows)
        {
            affectedRows = 0;

            throw new Exception("This method is obsolete (because it blindly executes the SQL); do not use");

            /*
                // Updates a database table as specified in the SQL statement

                affectedRows = 0;

                // Verify database connection is open
                if (!OpenConnection())
                    return false;

                try
                {
                    var cmd = new SqlCommand(SQL, m_DBCn);
                    affectedRows = cmd.ExecuteNonQuery();
                    return true;
                }
                catch (Exception ex)
                {
                    // If error happened, log it
                    OnError("Error updating database", ex);
                    return false;
                }
                finally
                {
                    m_DBCn.Close();
                }
              */
        }

        /// <summary>
        /// Method for executing a db stored procedure if a data table is to be returned
        /// </summary>
        /// <param name="spCmd">SQL command object containing stored procedure params</param>
        /// <param name="readMethod">method to read and return data from the command; command will be ready to run, executing and processing of returned data is left to the this Action</param>
        /// <param name="retryCount">Maximum number of times to attempt to call the stored procedure</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        private int ExecuteSPData(
            DbCommand spCmd,
            Action<SqlCommand> readMethod,
            int retryCount,
            int retryDelaySeconds)
        {
            if (spCmd is not SqlCommand sqlCmd)
            {
                if (spCmd == null)
                {
                    throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of 'null'.", nameof(spCmd));
                }

                throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of type {spCmd.GetType().FullName}.", nameof(spCmd));
            }

            // If this value is in error msg, exception occurred before resultCode was set
            var resultCode = -9999;

            var startTime = DateTime.UtcNow;

            if (retryCount < 1)
                retryCount = 1;

            if (retryDelaySeconds < 1)
                retryDelaySeconds = 1;

            var deadlockOccurred = false;

            // Make sure we dispose of the command object; however, it must be done outside of the while loop (since we use the same command for retries)
            // Could use clones for each try, but that would cause problems with "Output" parameters
            using (sqlCmd)
            {
                // Multiple retry loop for handling SP execution failures
                string errorMessage;
                while (retryCount > 0)
                {
                    var success = false;
                    try
                    {
                        using (var dbConnection = new SqlConnection(mConnStr))
                        {
                            dbConnection.InfoMessage += OnInfoMessage;
                            dbConnection.Open();

                            sqlCmd.Connection = dbConnection;

                            if (DebugMessagesEnabled)
                            {
                                OnDebugEvent("ExecuteSPData: " + sqlCmd.CommandText);
                            }

                            readMethod(sqlCmd);

                            resultCode = GetReturnCode(sqlCmd.Parameters);
                        }

                        success = true;
                    }
                    catch (Exception ex)
                    {
                        retryCount--;
                        errorMessage = "Exception filling data adapter for " + sqlCmd.CommandText + ": " + ex.Message;
                        errorMessage += "; resultCode = " + resultCode + "; Retry count = " + retryCount;
                        errorMessage += "; " + StackTraceFormatter.GetExceptionStackTrace(ex);

                        OnErrorEvent(errorMessage);

                        if (IsFatalException(ex) ||
                            ex.Message.StartsWith("Could not find stored procedure " + sqlCmd.CommandText))
                        {
                            retryCount = 0;
                        }
                        else if (ex.Message.Contains("was deadlocked"))
                        {
                            deadlockOccurred = true;
                        }
                    }
                    finally
                    {
                        if (DebugMessagesEnabled)
                        {
                            var debugMessage = "SP execution time: " + DateTime.UtcNow.Subtract(startTime).TotalSeconds.ToString("##0.000") +
                                               " seconds for SP " + sqlCmd.CommandText;

                            OnDebugEvent(debugMessage);
                        }
                    }

                    if (success)
                        break;

                    if (retryCount > 0)
                    {
                        ProgRunner.SleepMilliseconds(retryDelaySeconds * 1000);
                    }
                }

                if (retryCount < 1)
                {
                    // Too many retries, log and return error
                    errorMessage = "Excessive retries";
                    if (deadlockOccurred)
                    {
                        errorMessage += " (including deadlock)";
                    }
                    errorMessage += " executing SP " + sqlCmd.CommandText;

                    OnErrorEvent(errorMessage);

                    if (deadlockOccurred)
                    {
                        return DbUtilsConstants.RET_VAL_DEADLOCK;
                    }

                    return DbUtilsConstants.RET_VAL_EXCESSIVE_RETRIES;
                }
            }

            return resultCode;
        }

        /// <summary>
        /// Method for executing a db stored procedure if a data table is to be returned
        /// </summary>
        /// <param name="spCmd">SQL command object containing stored procedure params</param>
        /// <param name="results">If SP successful, contains Results (list of list of strings)</param>
        /// <param name="retryCount">Maximum number of times to attempt to call the stored procedure</param>
        /// <param name="maxRowsToReturn">Maximum rows to return; 0 for no limit</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        public int ExecuteSPData(
            DbCommand spCmd,
            out List<List<string>> results,
            int retryCount = 3,
            int maxRowsToReturn = 0,
            int retryDelaySeconds = 5)
        {
            // Declare a local variable to append the results to
            // This is required because we cannot use an out parameter in a lambda expression (the Action => block below)
            var dbResults = new List<List<string>>();
            results = dbResults;

            var readMethod = new Action<SqlCommand>(_ =>
            {
                using var reader = spCmd.ExecuteReader();

                while (reader.Read())
                {
                    var currentRow = new List<string>();

                    for (var columnIndex = 0; columnIndex < reader.FieldCount; columnIndex++)
                    {
                        var value = reader.GetValue(columnIndex);

                        if (DBNull.Value.Equals(value))
                        {
                            currentRow.Add(string.Empty);
                        }
                        else
                        {
                            currentRow.Add(value.ToString());
                        }
                    }

                    dbResults.Add(currentRow);

                    if (maxRowsToReturn > 0 && dbResults.Count >= maxRowsToReturn)
                    {
                        break;
                    }
                }
            });

            return ExecuteSPData(spCmd, readMethod, retryCount, retryDelaySeconds);
        }

        /// <summary>
        /// Method for executing a db stored procedure if a data table is to be returned
        /// </summary>
        /// <param name="spCmd">SQL command object containing stored procedure params</param>
        /// <param name="results">If SP successful, contains results as a DataTable</param>
        /// <param name="retryCount">Maximum number of times to attempt to call the stored procedure</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        public int ExecuteSPDataTable(
            DbCommand spCmd,
            out DataTable results,
            int retryCount = 3,
            int retryDelaySeconds = 5)
        {
            var queryResults = new DataTable();
            results = queryResults;
            var readMethod = new Action<SqlCommand>(x =>
            {
                using var da = new SqlDataAdapter(x);
                da.Fill(queryResults);
            });

            return ExecuteSPData(spCmd, readMethod, retryCount, retryDelaySeconds);
        }

        /// <summary>
        /// Method for executing a db stored procedure if a data table is to be returned
        /// </summary>
        /// <param name="spCmd">SQL command object containing stored procedure params</param>
        /// <param name="results">If SP successful, contains results as a DataSet</param>
        /// <param name="retryCount">Maximum number of times to attempt to call the stored procedure</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        public int ExecuteSPDataSet(
            DbCommand spCmd,
            out DataSet results,
            int retryCount = 3,
            int retryDelaySeconds = 5)
        {
            var queryResults = new DataSet();
            results = queryResults;
            var readMethod = new Action<SqlCommand>(x =>
            {
                using var da = new SqlDataAdapter(x);
                da.Fill(queryResults);
            });

            return ExecuteSPData(spCmd, readMethod, retryCount, retryDelaySeconds);
        }

        /// <summary>
        /// Method for executing a db stored procedure, assuming no data table is returned
        /// </summary>
        /// <param name="spCmd">SQL command object containing stored procedure params</param>
        /// <param name="maxRetryCount">Maximum number of times to attempt to call the stored procedure</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        public int ExecuteSP(
            DbCommand spCmd,
            int maxRetryCount = DbUtilsConstants.DEFAULT_SP_RETRY_COUNT,
            int retryDelaySeconds = DbUtilsConstants.DEFAULT_SP_RETRY_DELAY_SEC)
        {
            return ExecuteSP(spCmd, out _, maxRetryCount, retryDelaySeconds);
        }

        /// <summary>
        /// Method for executing a db stored procedure when a data table is not returned
        /// </summary>
        /// <remarks>No logging is performed by this procedure</remarks>
        /// <param name="spCmd">SQL command object containing stored procedure params</param>
        /// <param name="errorMessage">Error message (output)</param>
        /// <param name="maxRetryCount">Maximum number of times to attempt to call the stored procedure</param>
        /// <param name="retryDelaySeconds">Number of seconds to wait between retrying the call to the procedure</param>
        /// <returns>Result code returned by SP; -1 if unable to execute SP</returns>
        public int ExecuteSP(
            DbCommand spCmd,
            out string errorMessage,
            int maxRetryCount = DbUtilsConstants.DEFAULT_SP_RETRY_COUNT,
            int retryDelaySeconds = DbUtilsConstants.DEFAULT_SP_RETRY_DELAY_SEC)
        {
            if (spCmd is not SqlCommand sqlCmd)
            {
                if (spCmd == null)
                {
                    throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of 'null'.", nameof(spCmd));
                }

                throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of type {spCmd.GetType().FullName}.", nameof(spCmd));
            }

            // If this value is in error msg, exception occurred before resultCode was set
            var resultCode = -9999;

            var startTime = DateTime.UtcNow;
            var retryCount = maxRetryCount;
            var deadlockOccurred = false;

            errorMessage = string.Empty;

            if (retryCount < 1)
            {
                retryCount = 1;
            }

            if (retryDelaySeconds < 1)
            {
                retryDelaySeconds = 1;
            }

            // Make sure we dispose of the command object; however, it must be done outside of the while loop (since we use the same command for retries)
            // Could use clones for each try, but that would cause problems with "Output" parameters
            using (sqlCmd)
            {
                // Multiple retry loop for handling SP execution failures
                while (retryCount > 0)
                {
                    deadlockOccurred = false;
                    try
                    {
                        using (var dbConnection = new SqlConnection(mConnStr))
                        {
                            dbConnection.InfoMessage += OnInfoMessage;
                            dbConnection.Open();

                            sqlCmd.Connection = dbConnection;

                            if (DebugMessagesEnabled)
                            {
                                OnDebugEvent("ExecuteSP: " + spCmd.CommandText);
                            }

                            startTime = DateTime.UtcNow;
                            sqlCmd.ExecuteNonQuery();

                            resultCode = GetReturnCode(sqlCmd.Parameters);
                        }

                        errorMessage = string.Empty;
                        break;
                    }
                    catch (Exception ex)
                    {
                        retryCount--;
                        errorMessage = "Exception calling stored procedure " + sqlCmd.CommandText + ": " + ex.Message;
                        errorMessage += "; resultCode = " + resultCode + "; Retry count = " + retryCount;
                        errorMessage += "; " + StackTraceFormatter.GetExceptionStackTrace(ex);

                        OnErrorEvent(errorMessage);

                        if (IsFatalException(ex) ||
                            ex.Message.StartsWith("Could not find stored procedure " + sqlCmd.CommandText))
                        {
                            break;
                        }
                        else if (ex.Message.Contains("was deadlocked"))
                        {
                            deadlockOccurred = true;
                        }
                    }
                    finally
                    {
                        if (DebugMessagesEnabled)
                        {
                            var debugMessage = "SP execution time: " + DateTime.UtcNow.Subtract(startTime).TotalSeconds.ToString("##0.000") + " seconds for SP " + sqlCmd.CommandText;
                            OnDebugEvent(debugMessage);
                        }
                    }

                    if (retryCount > 0)
                    {
                        ProgRunner.SleepMilliseconds(retryDelaySeconds * 1000);
                    }
                }

                if (retryCount < 1)
                {
                    // Too many retries, log and return error
                    errorMessage = "Excessive retries";
                    if (deadlockOccurred)
                    {
                        errorMessage += " (including deadlock)";
                    }
                    errorMessage += " executing SP " + sqlCmd.CommandText;

                    OnErrorEvent(errorMessage);

                    if (deadlockOccurred)
                    {
                        return DbUtilsConstants.RET_VAL_DEADLOCK;
                    }

                    return DbUtilsConstants.RET_VAL_EXCESSIVE_RETRIES;
                }
            }

            return resultCode;
        }

        /// <inheritdoc />
        public DbCommand CreateCommand(string cmdText, CommandType cmdType = CommandType.Text)
        {
            return new SqlCommand(cmdText) { CommandType = cmdType, CommandTimeout = TimeoutSeconds };
        }

        /// <summary>
        /// Adds a parameter to the DbCommand, appropriate for the database type
        /// </summary>
        /// <remarks>
        /// If dbType is Text or VarChar, sets the parameter's value to string.Empty
        /// </remarks>
        /// <param name="command"></param>
        /// <param name="name">Parameter name</param>
        /// <param name="dbType">Database data type</param>
        /// <param name="direction">Parameter direction</param>
        /// <returns>The newly added parameter</returns>
        public override DbParameter AddParameter(
            DbCommand command,
            string name,
            SqlType dbType,
            ParameterDirection direction = ParameterDirection.Input)
        {
            return AddParameter(command, name, dbType, 0, direction);
        }

        /// <inheritdoc />
        public DbParameter AddParameter(
            DbCommand command,
            string name,
            SqlType dbType,
            int size,
            ParameterDirection direction = ParameterDirection.Input)
        {
            if (dbType == SqlType.Text)
            {
                return AddParameter(command, name, SqlType.Text, 0, string.Empty, direction);
            }

            if (dbType == SqlType.VarChar)
            {
                return AddParameter(command, name, dbType, size, string.Empty, direction);
            }

            return AddParameter(command, name, dbType, size, null, direction);
        }

        /// <inheritdoc />
        public DbParameter AddParameter(
            DbCommand command,
            string name,
            string dataTypeName,
            int size,
            ParameterDirection direction = ParameterDirection.Input)
        {
            var parameter = AddParameterByDataTypeName(command, name, dataTypeName, size, direction);
            return parameter;
        }

        /// <summary>
        /// Adds a parameter to the DbCommand, appropriate for the database type
        /// </summary>
        /// <param name="command"></param>
        /// <param name="name">Parameter name</param>
        /// <param name="dbType">Database data type</param>
        /// <param name="size">Size (typically for varchar, but sometimes for date and time)</param>
        /// <param name="value"></param>
        /// <param name="direction">Parameter direction</param>
        /// <returns>The newly added parameter</returns>
        public override DbParameter AddParameter(
            DbCommand command,
            string name,
            SqlType dbType,
            int size,
            object value,
            ParameterDirection direction = ParameterDirection.Input)
        {
            if (command is not SqlCommand sqlCmd)
            {
                throw new ArgumentException($"This method requires a parameter of type {typeof(SqlCommand).FullName}, but got an argument of type {command.GetType().FullName}.", nameof(command));
            }

            var param = new SqlParameter(name, ConvertSqlType(dbType), size)
            {
                Direction = direction,
                Value = value,
            };

            if (dbType == SqlType.Decimal)
                SetDefaultPrecision(param);

            sqlCmd.Parameters.Add(param);

            return param;
        }

        /// <inheritdoc />
        public DbParameter AddTypedParameter<T>(
            DbCommand command,
            string name,
            SqlType dbType,
            int size = 0,
            T value = default,
            ParameterDirection direction = ParameterDirection.Input)
        {
            return AddParameter(command, name, dbType, size, value, direction);
        }

        /// <summary>
        /// Convert from enum SqlType to System.Data.SqlDbType
        /// </summary>
        /// <param name="sqlType"></param>
        private SqlDbType ConvertSqlType(SqlType sqlType)
        {
            return sqlType switch
            {
                SqlType.Bit => SqlDbType.Bit,
                SqlType.Boolean or SqlType.TinyInt => SqlDbType.TinyInt,
                SqlType.SmallInt => SqlDbType.SmallInt,
                SqlType.Int => SqlDbType.Int,
                SqlType.BigInt => SqlDbType.BigInt,
                SqlType.Real => SqlDbType.Real,
                SqlType.Float => SqlDbType.Float,
                SqlType.Decimal => SqlDbType.Decimal,       // Includes Numeric
                SqlType.Money => SqlDbType.Money,
                SqlType.Char => SqlDbType.Char,
                SqlType.VarChar => SqlDbType.VarChar,
                SqlType.Text or SqlType.Citext or SqlType.Name => SqlDbType.Text,
                SqlType.Date => SqlDbType.Date,
                SqlType.Time => SqlDbType.Time,
                SqlType.DateTime => SqlDbType.DateTime,     // Includes Timestamp
                SqlType.TimestampTz => SqlDbType.DateTimeOffset,
                SqlType.UUID => SqlDbType.UniqueIdentifier,
                SqlType.XML => SqlDbType.Xml,
                SqlType.Interval => throw new NotSupportedException($"SQL Server does not support the {sqlType} type"),
                SqlType.JSON => throw new NotSupportedException($"SQL Server does not support the {sqlType} type"),
                _ => throw new ArgumentOutOfRangeException(nameof(sqlType), sqlType, $"Conversion for SqlType {sqlType} is not defined"),
            };
        }

        /// <summary>
        /// Examine the exception message to determine whether it is safe to rerun a failed query or failed stored procedure execution
        /// </summary>
        /// <param name="ex">Exception</param>
        /// <returns>True if the same error will happen again, so a retry is pointless</returns>
        protected bool IsFatalException(Exception ex)
        {
            return
                ex.Message.IndexOf("Login failed", StringComparison.OrdinalIgnoreCase) >= 0 ||
                ex.Message.IndexOf("Invalid object name", StringComparison.OrdinalIgnoreCase) >= 0 ||
                ex.Message.IndexOf("Invalid column name", StringComparison.OrdinalIgnoreCase) >= 0 ||
                ex.Message.IndexOf("permission was denied", StringComparison.OrdinalIgnoreCase) >= 0;
        }
    }
}
